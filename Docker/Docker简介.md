---
title: Docker简介
categories: Docker
tags: [Docker]
---

Docker是一种虚拟化技术解决开发环境和生产环境环境一致的问题，通过Docker可以将程序运行的环境也纳入到版本控制中，解决一些项目交付时的麻烦。

![docker架构](http://pgmrhouhm.bkt.clouddn.com/docker%E6%9E%B6%E6%9E%84.jpg)

## 解决的问题

由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。

Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其他机器中

## 优势

- 启动快

容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多

- 资源占用少

容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外多个容器可以共享资源，虚拟机都是独享资源

- 体积小

容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多

- 容易迁移

提供一致性的运行环境，可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行

- 容易维护

使用分层技术和镜像，使得应用可以更容易复用重复部分。复用程度越高，维护工作也越容易

- 容易扩展

可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像

## 底层技术支持

Namespaces：通过Linux的Namespaces对不同的容器实现了隔离，包括进程、网络等信息。通过挂载点映射和宿主机的目录。

ControlGroups：隔离宿主机器上的物理资源，例如CPU、内存、磁盘I/O和网络带宽。

UnionFileSystems：container和image的分层。

<!--more-->

## image

可以使用`docker images ls  `命令查看本机的image

* 文件和metadata的集合

* 分层，每层都可以添加、改变、删除文件

* image本身是只读的

**获取方式**

* 可以通过Dockerfile构建自己的image，使用`docker build`获取image

```
FROM ubuntu:15.04
COPY . /app
RUN make /app
CMD python /app/app.py
```

* `docker pull rabbitmq:management`拉取image

## container

可以使用`docker container ls  `命令查看本机的container 

* 通过image创建
* 类比面向对象：image是类，container是实例
* 负责运行

`docker run -it xxx` 可以进container里面进行一些操作

docker exec -it cname /bin/bash 进入容器

## 镜像与容器

镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。

镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。

构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。

通过**容器技术**有效分配和管理物理资源，实现资源隔离

通过**镜像技术**从系统环境开始，自底至上打包应用 