---
title: 数据库索引
categories: 数据库
tags: [索引]
---

## MySQL索引

索引是在存储引擎层实现的，不同的存储引擎具有不同的索引类型和实现方式

**B+Tree**

B+Tree是一种专门针对磁盘存储而优化的N叉排序树，以树的节点为单位存储在磁盘中，从根开始查找所需数据所在的节点编号和磁盘位置，将其加载到内存中然后继续查找，直到找到所需的数据。

B+Tree是大多数MySQL存储引擎默认的索引类型，是基于B-Tree和叶子节点顺序访问指针实现的，它所有叶子节点位于同一层，并且通过顺序访问指针来提高区间查询的性能。

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找对应的数据

插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性

![B+Tree](http://images.cnblogs.com/cnblogs_com/maruami/1277799/o_B-Tree.PNG)

<!-- more -->

[B+Tree插入删除查找演示地址（需翻墙）](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

而许多NoSQL使用LSM树作为主要的数据结构，在LSM树上进行一次数据更新不需要磁盘访问，在内存即可完成，速度远超B+Tree。

数据库在做查询时IO消耗比较大，B+Tree每到一层就发生一次IO操作，为了减少IO操作，提高查询效率，要让这棵树尽可能的低

利于计算机的预读特性，内存和磁盘以片为单位读取数据，将连续的数据放到同一片里，读取会更快

红黑树也可以用来实现索引，但是树高，所以IO次数多

**Hash**

基于Hash表，查找速度很快，一般情况下查找的时间复杂度O(1)，仅需要一次查找就能定位数据。缺点：

- 失去有序性，无法用于排序和分组
- 只支持精确查找，无法用于部分查找和范围查找

在InnoDB引擎中，数据库自优化生成Hash索引

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，数据库根据查询情况，对使用频繁的索引自优化生成Hash索引

**Fulltext**

全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等，查找条件使用 MATCH AGAINST，而不是普通的 WHERE。InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引

**R-Tree**

空间数据索引,可以用于地理数据存储。空间数据索引会从所有维度来查找数据，可以有效地使用任意维度来进行组合查询，必须使用 GIS 相关的函数来维护数据

### 聚集索引 · 非聚集索引

**聚集索引**

索引的键值逻辑顺序决定数据行的物理存储顺序

InnoDB主索引的叶子节点 data 域记录着完整的数据记录，因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

![主索引](http://images.cnblogs.com/cnblogs_com/maruami/1277799/o_1343758042_8526.png)

辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找

![辅助索引](http://images.cnblogs.com/cnblogs_com/maruami/1277799/o_1343758434_9462.png)

所以**不要使用过长的字段作为主键**，过长的主索引会令辅助索引变得过大

推荐使用自增字段作为主键，否则非自增的主键会造成在插入新记录时，索引会为了维持B+Tree的特性而频繁的分裂调整

**非聚集索引**

索引的键值逻辑顺序，但数据行的物理存储地址不一定顺序

MyISAM叶子节点存放的是数据的物理地址而不是数据本身。在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用

![](http://images.cnblogs.com/cnblogs_com/maruami/1277799/o_1343757655_1008.png)

### 单一索引 · 复合索引

**单一索引**

新建索引的语句只实施在一列上，**索引要建在数据区分度高的列上**，像sex这种区分度低的就不需要单独建索引

**复合索引**

可以指定多个列作为索引列，组成复合索引。索引列**数据区分度高**的放在前面

- 按照where条件建索引，索引包含所有需要查询的字段的值
- 有复合索引unionindex(column1,column2)，就没有必要再建index(column1)
- 复合索引的索引列不要太多

## 优点

- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 减少需要扫描的数据行数，加快数据的查询速度
- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量

## 缺点

- 随着数据量的增加，建立和维护索引的时间和空间也会增加
- 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。会增加数据库写操作的成本，降低表更新的速度
- 会增加查询优化器的选择时间

## 如何创建索引

**在哪儿建索引**

- 经常需要搜索的列上，可以加快搜索的速度
- 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
- 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
- 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
- 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
- 多表join关联列
- select update delete where 的列
- orderby groupby distinct中的字段
- 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
- 选择索引列的顺序
  - 区分度最高的放最左侧
  - 字段长度小的列放左
  - 最频繁使用的列放左

**不该在哪儿建索引**

- 对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
- 对于那些只有数据值区分区很小的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
- 数据类型为text, image和bit数据类型的列不应该增加索引
- 当修改性能远远大于检索性能时，不应该创建索引。这是因为，**修改性能和检索性能是互相矛盾的**。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

## 索引失效

**索引列是表达式的一部分或函数的参数不能使用索引**

```sql
select * from tbl_user where id+1=2;
select * from tbl_user having max(id);
```

**复合索引最左前缀不能使用索引**

```sql
create index index_id_username on tbl_user(id,username);
select * from tbl_user where username='root';
```

**负向查询不能使用索引**

```sql
select name from user where id not in (1,3,4);
```

**前导模糊查询不能使用索引**

```sql
select name from user where name like '%zhangsan'
```

## 索引原理

局部性原理与磁盘预读：由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的**局部性原理**：**当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。**

由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。

预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。

根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：

每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。

**B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。**一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。

而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

## explain

通过MySQL工具explain+查询语句

- select_type : 查询类型，有简单查询、联合查询、子查询等
- key : 使用的索引
- rows : 扫描的行数