---
title: SQL语句优化
categories: 数据库
tags: [SQL]
---
- 只返回必要的列，减少查询字段数，不使用select *
- 只返回必要的行   limit限制返回的数据， 确定只要一行数据时使用limit 1
- 缓存重复查询的数据
- 使用索引减少扫描次数
- 切分大查询 如果一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询，所以要切分
- 分解大连接查询   让缓存更高效 对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用
- 在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好
- 对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符
- 冷热数据分离 历史数据归档
- 不使用uuid md5 hash 字符串作为主键
<!-- more -->
- 使用分区表 逻辑上是一张表 物理上存在不同的表上（list,hash,range）
- 避免使用子查询 会产生大量的临时表 子查询的没有索引
- 合理使用join，表关联尽量用主键
- where 从句不要使用函数转换或计算，会导致无法使用索引
- 尽量不在数据库做运算，否则无法使用索引导致全表扫描
- 避免前缀模糊查询  用不了索引导致全表扫描  
- 控制表单数据量    合理分表  单库不超过300-400个表
- 表字段少而精   字段上限控制在20-50个
- 效率优先 可以适当冗余
- 用好数据字段类型 tinyint int bigint 
- 字符转化为数字   数字型更高效 查询更快 占用空间小
- 避免使用null 字段    难以进行查询优化  null列加索引，需要额外的空间按     含null复合索引无效
- 字符字段必须建前缀索引  ALTER TABLE messages_messagehistory ADD KEY (messagecontent(8))
- 尽量不用外键   有额外开销  高并发容易死锁
- 大sql拆解成多条简单sql   缓存命中高   减少锁表时间  能用上更多的cpu
- 保持事务连接短小    与事务无关的操作放到事务外面
- 避免负向查询       如 not   !=   <>   !<  !>   not exists  not in   not like
- 减少count(*)   资源开销大
- 无需对结果去重时，用union all ,    union有去重开销
- 同数据类型的列值比较  数字对数字  字符对字符  字符列与数值类型比较   字符列转成数值，不会使用索引查询
- 两个表join的字段 数据类型要相同