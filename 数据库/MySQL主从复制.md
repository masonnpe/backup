---
title: MySQL主从复制
categories: 数据库
tags: []
---

## MySQL主从复制原理

![image](http://ws4.sinaimg.cn/large/007iUdjSgy1fy6jgnueisj30pz0k6774.jpg)

<!-- more -->

主库将增删改操作写binlog日志，从库连接到主库之后有一个IO线程，将主库的binlog日志拷贝到本地，写入到一个中继日志中，接着从库中有一个SQL线程会从中继日志读取binlog日志，并执行binlog日志中的内容，也就是在本地再次执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。这里有一个非常重要的点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。

如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。所以MySQL在这一块有两个机制，一个是半同步复制，用来解决主库数据丢失问题；一个是并行复制，用来解决主从同步延时问题。

半同步复制（semi-sync复制），指的就是主库写入binlog日志之后，就会立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。

并行复制，指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。

## MySQL主从同步延时

 一般在读远远多于写的场景下来用这个MySQL主从同步，而且读的时候一般对数据时效性要求没那么高。主从同步延时问题，会导致一些线上的bug难以发现。可以通过show status，Seconds_Behind_Master，看到从库复制主库的数据落后了多少ms。

虽然可以用MySQL的并行复制，但是那是库级别的并行，时候作用不是很大。所以对于那种写了之后立马就要保证可以查到的场景，采用强制读主库的方式，这样就可以保证可以读到数据。也可以重写业务代码比如第二句SQL不依赖第一句SQL，就直接更新不查询，如果依赖就先读判断结果是否为空，如果为空就报错下次重试。

## 实现MySQL的读写分离

基于主从复制架构，简单来说就是搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。