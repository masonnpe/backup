---
title: JVM组成
categories: JVM
tags: [JVM]
---

![JVM](http://pgmrhouhm.bkt.clouddn.com/jvm.PNG)

方法区和堆内存是线程**共享**的。程序计数器、虚拟机栈、本地方法栈是线程**私有**的

## 方法区

存放已经被JVM加载的类的信息，如常量，静态变量、即时编译器编译后的代码等。

从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中，1.8 metaspace 放类加载信息

## 堆内存

![jmm](http://pgmrhouhm.bkt.clouddn.com/jmm.PNG)

所有对象的创建都在这里进行分配，采取分代管理，分为新生代和老年代，执行不同的垃圾回收策略，所有**实例域，静态域和数组元素**都是放在堆内存中。常量池在堆中

<!--more-->

## 程序计数器

指向当前线程执行的字节码行号，多线程切换时可以知道上一次运行的状态和位置

## 虚拟机栈

![虚拟机栈](http://pgmrhouhm.bkt.clouddn.com/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.PNG)

由一个个栈帧组成，每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用、方法的调用返回等信息，每创建一个栈帧压栈，当一个方法执行完毕之后则出栈

该区域可能抛出以下异常：

- 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常
- 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常

## 本地方法栈

调用Native Method

## 直接内存

在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存（Native 堆），然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据

