# 分布式事务

本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

（1）分布式事务了解吗？你们如何解决分布式事务问题的？TCC如果出现网络连不通怎么办？XA的一致性如何保证？



（1）两阶段提交方案/XA方案

所以这个就是所谓的XA事务，两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复ok，那么就正式提交事务，在各个数据库上执行操作；如果任何一个数据库回答不ok，那么就回滚事务。

 

这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于spring + JTA就可以搞定，自己随便搜个demo看看就知道了。

 

这个方案，我们很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几百个服务，几十个服务。一般来说，我们的规定和规范，是要求说每个服务只能操作自己对应的一个数据库。

 

如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，经常数据被别人改错，自己的库被别人写挂。

 

如果你要操作别人的服务的库，你必须是通过调用别的服务的接口来实现，绝对不允许你交叉访问别人的数据库！

 

（2）TCC方案 Try、Confirm、Cancel

这个其实是用到了补偿的概念，分为了三个阶段：  

给大家举个例子吧，比如说跨银行转账的时候，要涉及到两个银行的分布式事务，如果用TCC方案来实现，思路是这样的：

1）Try阶段：先把两个银行账户中的资金给它冻结住就不让操作了

2）Confirm阶段：执行实际的转账操作，A银行账户的资金扣减，B银行账户的资金增加

3）Cancel阶段：如果任何一个银行的操作执行失败，那么就需要回滚进行补偿，就是比如A银行账户如果已经扣减了，但是B银行账户资金增加失败了，那么就得把A银行账户资金给加回去

 

这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大，非常之恶心,很难维护。 

比较适合的场景：一致性要求很高，比如常见的就是资金类的场景，那你可以用TCC方案了，自己编写大量的业务逻辑，自己判断一个事务中的各个环节是否ok，不ok就执行补偿/回滚代码，严格保证资金的正确性

（3）本地消息表



1月份做的统一网关支付平台，CMBB2B的前置机模式要求要和前置机放在一起，为了方便处理方便将银行的后台通知放在了客户端接受，再发给网关，网关更新支付状态成功后，再告诉客户端结果，再让客户端更新，更新成功再返回成功接受的报文，告诉银行不需要再发送通知了。整个过程是同步的，响应过慢可能会造成线程阻塞卡死，想了想好像跟分布式事务有点关系

![image](https://wx3.sinaimg.cn/large/007iUdjSgy1fytf06bl49j30up0e1gn4.jpg)

1）A系统在自己本地一个事务里操作同时，插入一条数据到消息表

2）接着A系统将这个消息发送到MQ中去

3）B系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息

4）B系统执行成功之后，就会更新自己本地消息表的状态以及A系统消息表的状态

5）如果B系统处理失败了，那么就不会更新消息表状态，那么此时A系统会定时扫描自己的消息表，如果有没处理的消息，会再次发送到MQ中去，让B再次处理

6）这个方案保证了最终一致性，哪怕B事务失败了，但是A会不断重发消息，直到B那边成功为止

 

一般确实很少用，这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务，高并发场景不适合，不好扩展

 

（4）可靠消息最终一致性方案

![image](https://ws4.sinaimg.cn/large/007iUdjSgy1fytf0x7mnij30sn0dqdhu.jpg)



这个的意思，就是干脆不要用本地的消息表了，直接基于MQ来实现事务。比如阿里的RocketMQ就支持消息事务。

 

大概的意思就是：

1）A系统先发送一个prepared消息到mq，如果这个prepared消息发送失败那么就直接取消操作别执行了

2）如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉mq发送确认消息，如果失败就告诉mq回滚消息

3）如果发送了确认消息，那么此时B系统会接收到确认消息，然后执行本地的事务

4）mq会自动定时轮询所有prepared消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认消息？那是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，别确认消息发送失败了。

5）这个方案里，要是系统B的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如B系统本地回滚后，想办法通知系统A也回滚；或者是发送报警由人工来手工回滚和补偿

 

这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用RocketMQ支持的，要不你就自己基于类似ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的

 

（5）最大努力通知方案

允许少数的分布式事务失败，用于对分布式事务不严格的情况，比如记录日志



这个方案的大致意思就是：

 

1）系统A本地事务执行完之后，发送个消息到MQ

2）这里会有个专门消费MQ的最大努力通知服务，这个服务会消费MQ然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统B的接口

3）要是系统B执行成功就ok了；要是系统B执行失败了，那么最大努力通知服务就定时尝试重新调用系统B，反复N次，最后还是不行就放弃

 

（6）你们公司是如何处理分布式事务的？

 

一个严格资金要求绝对不能错的场景，你可以说你是用的TCC方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案



要用分布式事务的时候，一定是有成本，代码会很复杂，开发很长时间，性能和吞吐量下跌，系统更加复杂更加脆弱反而更加容易出bug；好处，如果做好了，TCC、可靠消息最终一致性方案，一定可以100%保证你那快数据不会出错。

 

资金、交易、订单，会用分布式事务方案来保证







#### 背景

数据库事务ACID

mysql的事务处理过程

1. 记录redo和undo.log文件，确保日志在磁盘上的持久化
2. 更新数据记录
3. 提交事务，redo写入commit记录

分库分表变成几个库了

#### 

#### 2PC 

2-phase-commit

2PC顾名思义分为两个阶段，其实施思路可概括为：

（1）投票阶段（voting phase）：

​	1. 协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行结果。

1. 事务参与者收到请求之后，执行事务，但不提交，并记录事务日志。
2. 参与者将自己事务执行情况反馈给协调者，同时阻塞等待协调者的后续指令。	

（2）提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；

1. 所有的参与者回复能够正常执行事务

   ​	

   1. 协调者向各个参与者发送commit通知，请求提交事务。
   2. 参与者收到事务提交通知之后，执行commit操作，然后释放占有的资源。
   3. 参与者向协调者返回事务commit结果信息。

2. 一个或多个参与者回复事务执行失败

   ​	

   1. 协调者向各个参与者发送事务rollback通知，请求回滚事务。
   2. 参与者收到事务回滚通知之后，执行rollback操作，然后释放占有的资源。
   3. 参与者向协调者返回事务rollback结果信息。

3. 协调者等待超时。	

   ​	

tm向所/有的ap发送事务内容，询问是否可以执行事务的提交操作，并等待各个ap的响应

都为yes 发送commit请求执行事务   commit操作很快，失败概率比较小，增大了事务的成功概率

问题：

- 单点问题
  协调者在整个两阶段提交过程中扮演着举足轻重的作用，一旦协调者所在服务器宕机，那么就会影响整个数据库集群的正常运行，比如在第二阶段中，如果协调者因为故障不能正常发送事务提交或回滚通知，那么参与者们将一直处于阻塞状态，整个数据库集群将无法提供服务。
- 同步阻塞
  两阶段提交执行过程中，所有的参与者都需要听从协调者的统一调度，期间处于阻塞状态而不能从事其他操作，这样**效率及其低下**。
- 数据不一致性
  两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了 事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这 时候就产 生了数据的不一致性



3pc

canCommit

1. 协调者向各个参与者发送事务询问通知，询问是否可以执行事务操作，并等待回复
2. 各个参与者依据自身状况回复一个预估值，如果预估自己能够正常执行事务就返回确定信息，并进入预备状态，否则返回否定信息

preCommit

doCommit



jotm

atomikos

https://blog.csdn.net/sofia1217/article/details/53968177











