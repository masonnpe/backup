---
title: volatile实现原理
categories: 并发编程
tags: [volatile]
---

## 实现原理

在对被`volatile`修饰的共享变量进行写操作时，会多出`Lock`前缀的指令。作用是：

1. 将当前处理器缓存行的数据写回到系统内存；
2. 使得其他CPU里缓存了该内存地址的数据无效；
3. 当处理器发现本地缓存失效后，就会从内存中重新读取该变量数据。

通过这样的机制就使得每个线程都能获得该变量的最新值，从而避免出现数据脏读的现象。

> 为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，操作完成后不知道何时将数据写回到内存。如果对声明了`volatile`的变量进行写操作，虚拟机就会向处理器发送一条`Lock`前缀的指令，将这个变量所在缓存行的数据写回到系统内存。在多处理器下为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议（每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期），当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

<!--more-->

## volatile与重排序

为了实现`volatile`的内存语义，JMM会通过插入内存屏障指令来限制特定类型的编译器和处理器重排序

- 在每个`volatile`读后面插入一个LoadLoad屏障：禁止下面所有的普通读操作和上面的`volatile`读重排序
- 在每个`volatile`读后面插入一个LoadStore屏障：禁止下面所有的普通写操作和上面的`volatile`读重排序
- 在每个`volatile`写前面插入一个StoreStore屏障：禁止上面的普通写和下面的`volatile`写重排序
- 在每个`volatile`写后面插入一个StoreLoad屏障：防止上面的`volatile`写与下面可能有的`volatile`读/写重排序