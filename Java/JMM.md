线程安全问题一般是因为**主内存和本地内存数据不一致**和**重排序**导致的

**JMM**

java内存模型是**共享内存的并发模型**，线程之间主要通过读/写共享变量来完成隐式通信

在JVM中所有**实例域，静态域和数组元素**都是放在堆内存中是共享的，而局部变量、方法定义参数、异常处理器参数是线程私有的

**重排序**

在执行程序时，**为了提高性能，编译器和处理器常常会对指令进行重排序**

```
源代码→编译器优化重排序→指令集并行重排序→内存系统重排序→最终执行的指令序列
```

**编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序**



**as-if-serial**语义保证不管怎么重排序，单线程内程序的执行结果不被改变

**happens-before**关系保证正确同步的多线程程序的执行结果不被改变.**JMM可以通过happens-before提供跨线程的内存可见性保证**

**happens-before关系并不代表了最终的执行顺序**

出现线程安全的问题一般是因为**主内存和工作内存数据不一致性**和**重排序**导致的

**happens-before**

* 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
* 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
* volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
* 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
* start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
* join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。
* 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。
* 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。











在Java中线程之间通过写-读共享内存来隐式进行通信。

JVM中`堆`、`方法区`是线程共享的，`虚拟机栈`、`本地方法栈`、`程序计数器`是非线程共享的。堆内存中存放`类的实例`、`静态变量`和`数组`。虚拟机栈中存放`局部变量`。



为了提高性能，编译器和处理器常常会对指令做重排序。

- **编译器优化**的重排序：编译器在不改变单线程程序语义的前提下，重新安排语句的执行顺序。
- **指令集并行**的重排序：语句不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- **内存系统**的重排序：由于处理器使用缓存和读写缓冲区，加载和存储操作乱序。

读写顺序不一致

# happens-before

前一个操作的执行结果对后一个操作可见，且前一个操作顺序排在后一个操作之前，并不意味着前一个操作必要要在后一个操作之前执行？？？？

- 程序顺序规则：一个线程中每个操作，happens-before于该线程中的任意后续操作
- 监视器锁规则：对一个监视器的解锁，happens-before于随后对这个监视器的加锁
- volatile变量规则：对一个volatile的写，happens-before于任意后续对这个volatile域的读
- 传递性：如果A happens-before B，B happens-before C，那么A happens-before C

当代码中存在控制依赖性时，会影响指令序列执行的并行度。编译器和处理器会采用猜测执行，将计算结果临时保存到一个名为重排序缓冲区的硬件缓存中，猜对了就把计算结果写入。

64位的long型和double型变量的写操作拆分为两个32位的写操作来操作

# volatile

- 可见性：对一个volatile变量的读，总是能看到任意线程对这个volatile变量最后的写入
- 原子性：对任意单个volatile变量的读写具有原子性，但类似于i++这种复合操作不具有原子性

concurrent包的源代码实现

1. 声明共享变量volatile
2. 使用CAS更新来实现线程之间的同步
3. 配合volatile的读写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信

使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据 

使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率 

# final

1. 在构造函数内对一个final域的写入，与随后把这个构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序
2. 初次读一个包含final域的对象的引用与随后读这个final域，这两个操作之间不能重排序